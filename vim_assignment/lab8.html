<h1>Lab 8: Threading</h1>


<h2>References</h2>
<ul><a href=http://en.cppreference.com/w/cpp/thread>Thread</a></ul>
<ul><a href=http://en.cppreference.com/w/cpp/thread/unique_lock>Locks</a></ul>
<ul><a href=http://en.cppreference.com/w/cpp/thread/shared_mutex>Read/Write Locks</a></ul>


<h2>Threading</h2>
This week, we will take everything we have and make it all work together
using threads. Threading occurs in two steps: we <code>create</code> the
thread using a function pointer and arguments, and we <code>join</code>
the threads, which prevents the program from continuing until all threads
have terminated. This part is relatively straightforward. The tricky parts
are ensuring that none of the threads get in another's way (talked about in
the next section) and using threads in a way that actually speeds up the
program. Threads are really only useful in scenarios where the program sits
idly for an extended period. This could happen as a result of blocking
functions such as <code>getch()</code>, or I/O operations that are slow such
as reading/writing to files and writing to the display. Thus, in this
assignment, we will use threads to listen for keystrokes, write to the
file system (on saving) and write to the display. The spawning thread will be
the one that writes to the display (via ncurses). To use threads, we will use
<code>std::thread</code>, which will require that we
<code>#include &lt;thread&gt;</code>.


<h2>Shared Resources</h2>
When threading, you must be EXTREMELY conscientious of memory that is accessed
by more than one thread. One way to do this is with locks (also known as
mutexes). These work as a resource that a thread must "own" before reading
or writing. Only one thread can "own" it at any one time. Thus, if a thread
owns the lock and is writing to the shared resource, then no other thread
can be writing because it does own the lock. The two main operations we
can do with a lock are acquire and release. In our program, we will use
blocking locks, which means acquire will not return until it has the lock.
This is very susceptible to deadlocking, so we will have to be careful in our
implementation. This same construct is also used before reading shared
resources because we don't want one thread to read a value, another to change
it, then the original to respond to the original, now wrong, value. This
might seem inefficient because it allows only one thread to read a shared
resource at any one time. The solution to this is a read-write lock. The
difference here is when trying to acquire the lock, you declare whether it is
to read or write. The way these work is the lock keeps track of how many
threads are reading at all times and uses this count to determine whether it
should provide access to the resource. Each time a new thread wants to acquire
to read, the count increments. When it releases from reading, the count
decrements. When a thread wants to acqurie to write, it will block until no
other thread is accessing the resource, both readers and writers. In any case,
acquire will always block until nobody is writing. There is one particularly
interesting use case:
<pre class="prettyprint code">
    if (we want to write to shared resource) {
        acquire write lock
        do the write
        release write lock
    }
</pre>
This naive solution for such a case will not work. The first issue is that
we must presumably read the shared resource to check the <code>if</code>
condition. One possible solution is to move the write lock acquisition to
outside the <code>if</code>. While this works, it's slow because it must
wait until nobody is reading before checking. Furthermore, it forces any other
threads wanting to read to wait until it is done. In the end, it may not even
do a write. Therefore, we will want to acquire a read lock before the if
statement. Now, the issue is when the condition evaluates to true.
We can't acquire the write lock before releasing the read lock, because
that will deadlock as the write acquire waits for the read release that doesn't
occur until after the if. Likewise, it can't release the read lock, acquire
the write lock, then write because in between the release and acquire, the
resource may change such that we no longer want to write. The fastest solution
to such a scenario, which seems inefficient, is to do the same check twice.
In general, we want to spend as little time as possible with resources locked.
For example:
<pre class="prettyprint code">
    acquire read lock
    if (we want to write to shared resource) {
        release read lock
        acquire write lock
        if (we want to write to shared resource) {
            do the write
        }
        release write lock
    }
    release read lock
</pre>
To use read/write locks, we will use <code>std::shared_mutex</code>, which
will require that we <code>#include &lt;shared_mutex&gt;</code>. This
particular object uses the nomenclature <code>lock()</code> to acquire the
lock to write, <code>lock_shared()</code> to acqurie the lock to read,
<code>unlock()</code> to release the lock after writing, and
<code>unlock_shared()</code> to release the lock after reading. Note that
there also exist <code>try_lock()</code> and <code>try_lock_shared()</code>
which return <code>true</code> if and only if it acquires the lock, and do NOT
block if lock acquisition fails.


<h2>Autorecovery</h2>
Some editors have an autosave feature. The way this works is the editor
creates a temporary file that it saves changes to as they are made. This
is what is used as an automatic backup in case the editor closes unexpectedly.
Usually, text editors are extremely robust so that it doesn't accidentally
overwrite another file. For this, we will just put a "_temp" suffix on our
temporary files, as this should be sufficient to teach a point and we'll be
smart enough not to create files with "_temp" after the file extension. Now,
there are a few guidelines on how to use this. Periodically during use of our
text editor, we will save the file contents from our array to our _temp file,
unsolicited by the user. On normal exit, we delete the _temp file. On start,
we check for the existence of this _temp file. If it exists, then the editor
didn't exit normally last time, and we will load from this file instead of the
argued one (text editors should ask the user first, but we won't for the sake
of time). If it doesn't exist, load the argued file as normal and create a
_temp file for this session. You should never save to the argued file
unsolicited! That only happens when the user requests it.


<h2>Assignment</h2>
Your assignment is to implement autorecovery (it should be relatively little
work) and make <code>Vim</code> faster by using threads, and being
thread-safe where applicable. The way we will do this is by spawning a thread
whenever we <code>refresh()</code> the display and whenever we
<code>save()</code>. The way this is done is up to you, whether you want
one thread for each that doesn't exit until a flag is set by your quitting
mechanism, or creating a new thread each time you need to, then deleting it
as soon as it is done. For threading to be useful for saving, we want to not
lock the string vector for the entire duration. Doing that would basically be
the same as doing it all in one thread. Instead, you should have a lock for the
string vector as well as one for every string in the vector. When only one
line is being accessed, we only need to lock that line (read or write
respectively) as well as read-lock the entire vector. Then, only if we need
to add or remove a line will we write lock the entire vector. This helps us
because we can write to multiple lines at the same time. When we save, we
do one line at a time, which allows us to write to other lines simultaneously.
The last thread we will create is one that periodically (maybe once every
minute or so) saves a backup. In the spirit of drilling smart pointers into
you, continue using exclusively smart pointers where applicable.


<h2>Submission</h2>
Email me (Tim) a tarball of your entire directory, and on csman, submit with
no files so I can still give a grade back. I will email back a tarball with
your graded submission.
